---
description: SET â€” update vertices and edges
---

# SET

### Synopsis

```sql
PREVIOUS_CLAUSE
SET { entity_name.property_name = { expression | DEFAULT } |
      ( entity_name.property_name [, ...] ) = ( sub-QUERY )
    } [, ...]
NEXT_CLAUSE
```

### Description

`SET` changes the values of the specified vertex or edge in all rows that are given from the previous clause, regardless of whether they are filtered in a later clause.&#x20;

There are two ways to modify an entity using information contained in other entities in the database: using sub-query, or specifying additional entities in a previous `MATCH` `MERGE or CREATE`clause. Which technique is more appropriate depends on the specific circumstances.

You must have the `UPDATE` privilege on the label, or at least on the properties that are listed to be updated. You must also have the `SELECT` privilege on any column whose values are read in the _`expressions`_ or _`condition`_.

### Parameters

_`entity_name`_

The name of the entity to update.&#x20;

_`property_name`_

The name of a property in the entity named by _`entity_name`_. The property can be qualified with a subfield name or array subscript, if needed.&#x20;

_`expression`_

An expression to assign to the property. The expression can use the old values of this and other columns in the entity.

`DEFAULT`

Set the column to its default value (which will be NULL if no specific default expression has been assigned to it). An identity column will be set to a new value generated by the associated sequence. For a generated column, specifying this is permitted but merely specifies the normal behavior of computing the column from its generation expression.

_`sub-QUERY`_

A sub-query that produces as many output columns as are listed in the parenthesized column list preceding it. The sub-query must yield no more than one row when executed. If it yields one row, its column values are assigned to the target columns; if it yields no rows, NULL values are assigned to the target columns. The sub-query can refer to old values of the current row of the table being updated.

### Outputs

On successful completion, an `UPDATE` command returns a command tag of the form

```
UPDATE count
```

The _`count`_ is the number of rows updated, including matched rows whose values did not change. Note that the number may be less than the number of rows that matched the _`condition`_ when updates were suppressed by a `BEFORE UPDATE` trigger. If _`count`_ is 0, no rows were updated by the query (this is not considered an error).

If the `UPDATE` command contains a `RETURNING` clause, the result will be similar to that of a `SELECT` statement containing the columns and values defined in the `RETURNING` list, computed over the row(s) updated by the command.

### Notes

In the case of a partitioned label, updating a row might cause it to no longer satisfy the partition constraint of the containing partition. In that case, if there is some other partition in the partition tree for which this row satisfies its partition constraint, then the row is moved to that partition. If there is no such partition, an error will occur. Behind the scenes, the row movement is actually a `DELETE` and `CREATE` operation.

There is a possibility that a concurrent `SET` or `DELETE` on the row being moved will get a serialization failure error. Suppose session 1 is performing an `UPDATE` on a partition key, and meanwhile a concurrent session 2 for which this row is visible performs an `UPDATE` or `DELETE` operation on this row. In such case, session 2's `SET` or `DELETE` will detect the row movement and raise a serialization failure error (which always returns with an SQLSTATE code '40001'). Applications may wish to retry the transaction if this occurs. In the usual case where the table is not partitioned, or where there is no row movement, session 2 would have identified the newly updated row and carried out the `SET`/`DELETE` on this new row version.

Note that while rows can be moved from local partitions to a foreign-table partition (provided the foreign data wrapper supports tuple routing), they cannot be moved from a foreign-table partition to another partition.

An attempt of moving a row from one partition to another will fail if a foreign key is found to directly reference an ancestor of the source partition that is not the same as the ancestor that's mentioned in the `UPDATE` query.

### Examples

Change the word `Drama` to `Dramatic` in the column `kind` of the label `films`:

```sql
MATCH(film:films { kind: 'Drama' })
SET film.kind = 'Dramatic'
```

Adjust temperature entries and reset precipitation to its default value in one row of the table `weather`: &#x20;

```sql
MATCH (w:weather {city: 'San Francisco', date: '2003-07-03'})
SET w.temp_lo = w.temp_lo + 1,
    w.temp_hi = temp_lo + 15,
    prcp = DEFAULT
```

Perform the same operation and return the updated entries: &#x20;

```sql
MATCH (w:weather {city: 'San Francisco', date: '2003-07-03'})
SET w.temp_lo = w.temp_lo + 1,
    w.temp_hi = temp_lo + 15,
    prcp = DEFAULT
RETURN w.temp_lo, w.temp_hi, w.prcp
```

Perform the same operation, using a sub-select in the `WHERE` clause:

```sql
MATCH (emp:employees)
WHERE id = (MATCH (a:accounts { name: 'Acme Corporation'} RETURN a.sales_person))
SET emp.sales_count = emp.sales_count + 1
```

Update contact names in an accounts table to match the currently assigned salespeople:

```sql
MATCH (a:accounts)
SET (a.contact_first_name, a.contact_last_name) =
    (MATCH (e:employees {id: a.sales_person}) 
     RETURN e.first_name, e.last_name)
```

However, the second query may give unexpected results if `employees`.`id` is not a unique key, whereas the first query is guaranteed to raise an error if there are multiple `id` matches. Also, if there is no match for a particular `accounts`.`sales_person` entry, the first query will set the corresponding name fields to NULL, whereas the second query will not update that row at all.

Update statistics in a summary table to match the current data:

```sql
MATCH (s:summary)
SET (s.sum_x, s.sum_y, s.avg_x, s.avg_y) =
    (MATCH (e:employees {group_id: s.group_id}) 
     RETURN sum(e.x), sum(e.y), avg(e.x), avg(e.y))
```

